/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Tue Nov 28 2017 13:22:39 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of GenerateBehaviourModel.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin GenerateBehaviourModel.
     * @constructor
     */
    var GenerateBehaviourModel = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    GenerateBehaviourModel.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    GenerateBehaviourModel.prototype = Object.create(PluginBase.prototype);
    GenerateBehaviourModel.prototype.constructor = GenerateBehaviourModel;

	
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
	 
  GenerateBehaviourModel.prototype.generatetree = function(nodes, node) {
	 
	 var self = this,
	 core = this.core;
    // Initialize the objects
    var target = {
       name: '',
       MetaType: ''
    };
    
    //var metainfo = {name: '', path: '', nbrOfChildren: '', base: ''};
    
    // Set the required properties for the tree
    
    target.name = core.getAttribute(node, 'name');
    target.MetaType = core.getAttribute(core.getMetaType(node), 'name');
   // target.isMeta = core.isMetaNode(node);
    
    // Get user defined attributes of the node
    
     var attlist = core.getValidAttributeNames(node);
    //var attribute;
    if(attlist.length >0){
    for (let i =0; i<attlist.length;i+=1 ) { 
      var attname = attlist[i];
     target[attname] = core.getAttribute(node,attname);  
    }}
    
    // Get src and dst information for connections
    var srcPath = core.getPointerPath(node, 'src');
    var dstPath = core.getPointerPath(node, 'dst');
    
    //Only if both src and dst exist will the connection be accounted for
    
    if (srcPath && dstPath) {
      let srcNode = nodes[srcPath];
      let dstNode = nodes[dstPath];
      
     // save the values in target 
      
      target.src = core.getRelid(srcNode);
      target.dst = core.getRelid(dstNode);
	  }
    
    // Get the children paths of the current node
    
   var childrenpaths2 = core.getChildrenPaths(node);
    
   // Save the meta node info into the second array
   /* if (target.isMeta){
      metainfo.name = target.name;
      metainfo.path = core.getPath(node);
      metainfo.nbrOfChildren = childrenpaths2.length;
      metainfo.base = core.getBase(node);
      
   // get the base node and store it
      
      if(metainfo.base){
      metainfo.base = core.getAttribute(metainfo.base, 'name');
      }
      else{
        metainfo.base = null;
      }
      arrayJson.push(metainfo);
    }*/
     //logger.debug('Paths', childrenpaths2);
    if(target.MetaType == 'Guard'){
      target.src = '';
      target.dst = '';
    }
    
    if(target.MetaType == 'State' || target.MetaType == 'Default_State' || target.MetaType == 'Final_State'){
    target.link = {};
    
    // save the children data recursively
    
  for (let i = 0; i < childrenpaths2.length; i += 1) {
      var  childnode2 = nodes[childrenpaths2[i]];
      //logger.debug("Child:",core.getAttribute(childnode2,"name"));
    target.link[core.getRelid(childnode2)]= self.generatetree(nodes,childnode2);
    }}
    if(target.MetaType == 'Guard'){
    target.timer = {};
    
    // save the children data recursively
    
  for (let i = 0; i < childrenpaths2.length; i += 1) {
      childnode2 = nodes[childrenpaths2[i]];
      //logger.debug("Child:",core.getAttribute(childnode2,"name"));
    target.timer[core.getRelid(childnode2)]= self.generatetree(nodes,childnode2);
    }}
    return target;

  };
  
	 
    GenerateBehaviourModel.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,

        // Using the logger.
       /* self.logger.debug('This is a debug message.');
        self.logger.info('This is an info message.');
        self.logger.warn('This is a warning message.');
        self.logger.error('This is an error message.');*/

        // Using the coreAPI to make changes.

   // artifact = self.blobClient.createArtifact('ModelInfo'),
     activeNode = this.activeNode,
      core = this.core,
      logger = this.logger,
     modelJson = {
        name: '',
		MetaType: '',
        children: {},
      };
//var arrayJson = [];

 var FSMData = {
       name: '',
       InitialState: '',
       Intermediate_States: [],
       FinalState: '',
       Guards: [],
    };
  
  // Retrieve an object with all nodes in the subtree of activeNode
  
  this.loadNodeMap(activeNode)
    .then(function (nodes) {
    /*  for (let path in nodes) {
       //logger.debug(core.getAttribute(nodes[path], 'name'));
      }*/

      FSMData.name = core.getAttribute(activeNode, 'name');
      
      // Get all the children paths of the active node
      //    (these are the immediated children)
    
      var childrenPaths = core.getChildrenPaths(activeNode);
     // logger.debug('Paths', childrenPaths);
     //logger.debug('Length', childrenPaths.length);
      var childNode;
      
      // Iterate of the paths and retrieve the node using the node
      //    map
    
      for (let i = 0; i < childrenPaths.length; i += 1) {
        childNode = nodes[childrenPaths[i]];
        
        // Check the meta-type of the child-node and populae the object
        
        if (self.isMetaTypeOf(childNode, self.META.FCO)) {
          //logger.debug('Diagram:', core.getAttribute(childNode, 'name'));
         modelJson.children[core.getRelid(childNode)] =  self.generatetree(nodes, childNode);
        }
      }
	  
	  for(var object in modelJson.children){
     if(modelJson.children[object].MetaType == 'State'){
        //logger.debug('here');
        //logger.debug(JSON.stringify(modelJson.children[object]));
        FSMData.Intermediate_States.push(modelJson.children[object]);
     }
      if(modelJson.children[object].MetaType == 'Default_State'){
        //logger.debug('here');
        //logger.debug(JSON.stringify(modelJson.children[object]));
        FSMData.InitialState= modelJson.children[object];
     } 
      
       if(modelJson.children[object].MetaType == 'Final_State'){
        //logger.debug('here');
        //logger.debug(JSON.stringify(modelJson.children[object]));
        FSMData.FinalState = modelJson.children[object];
     }
      
     if(modelJson.children[object].MetaType == 'Transition'){
		 //var id = modelJson.children[object].dst;
       if(modelJson.children[modelJson.children[object].dst].MetaType == 'Guard'){
        modelJson.children[modelJson.children[object].dst].src = modelJson.children[modelJson.children[object].src].name;
        //logger.debug('here');
        //logger.debug(JSON.stringify(modelJson.children[object]));
       } 
       if(modelJson.children[modelJson.children[object].src].MetaType == 'Guard'){
         modelJson.children[modelJson.children[object].src].dst = modelJson.children[modelJson.children[object].dst].name;
        //logger.debug('here');
        //logger.debug(JSON.stringify(modelJson.children[object]));
       } 
     }  
    }
    for(object in modelJson.children){
     if(modelJson.children[object].MetaType == 'Guard'){
        //logger.debug('here');
        //logger.debug(JSON.stringify(modelJson.children[object]));
        FSMData.Guards.push(modelJson.children[object]);
     }
    }
    
    logger.debug('FSMData:');
    logger.debug(JSON.stringify(FSMData, null, 2));
    
    
  
    
    

      // Convert the data-structure into a string
    
     //logger.debug('modelJson',JSON.stringify(modelJson, null, 2));
    var FSM = JSON.stringify(FSMData, null, 2);
     //logger.debug(JSON.stringify(arrayJson, null, 2));
    //var meta = JSON.stringify(arrayJson, null, 2);
    
    // Save both files in the Blob
    
    return self.blobClient.putFile('FSM.json', FSM);
  })
   .then(function (metadataHash) {
    logger.info(metadataHash);
      //Link the uploaded file (using the hash) from the plugin result.
    
      self.result.addArtifact(metadataHash);
      self.result.setSuccess(true);
      callback(null, self.result);
    })
    .catch(function (err) {
      logger.error(err);
      callback(err);
    });
	};

    return GenerateBehaviourModel;
});
